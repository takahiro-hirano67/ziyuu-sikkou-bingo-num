This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
bingo-num-app/.gitignore
bingo-num-app/app/favicon.ico
bingo-num-app/app/globals.css
bingo-num-app/app/layout.tsx
bingo-num-app/app/page.tsx
bingo-num-app/app/ver-1/components/common/ExportButtons.tsx
bingo-num-app/app/ver-1/components/common/ShowInfo.tsx
bingo-num-app/app/ver-1/components/item/AnnouncePrizeNumItem.tsx
bingo-num-app/app/ver-1/components/item/DisclosureItem.tsx
bingo-num-app/app/ver-1/components/item/PrizeNumItem.tsx
bingo-num-app/app/ver-1/components/step/InAnnouncement.tsx
bingo-num-app/app/ver-1/components/step/InProgress.tsx
bingo-num-app/app/ver-1/components/step/InputForm.tsx
bingo-num-app/app/ver-1/components/step/SelectAnnounceOrder.tsx
bingo-num-app/app/ver-1/layout.tsx
bingo-num-app/app/ver-1/page.tsx
bingo-num-app/app/ver-1/PrizeObjectType.ts
bingo-num-app/app/ver-1/README.md
bingo-num-app/app/ver-2/page.tsx
bingo-num-app/eslint.config.mjs
bingo-num-app/imges/description_image.png
bingo-num-app/imges/edit_icon.svg
bingo-num-app/next.config.ts
bingo-num-app/package.json
bingo-num-app/postcss.config.mjs
bingo-num-app/README.md
bingo-num-app/tsconfig.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="bingo-num-app/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="bingo-num-app/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --font-family: var(--font-noto-sans-jp);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-noto-sans-jp), Arial, Helvetica, sans-serif;
}
</file>

<file path="bingo-num-app/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono, Noto_Sans_JP } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

const notoSansJP = Noto_Sans_JP({
  variable: "--font-noto-sans-jp",
  subsets: ["latin"],
  weight: ["100", "300", "400", "500", "700", "900"],
  display: "swap",
});

export const metadata: Metadata = {
  title: "Bingo Num App",
  description: "自由ヶ丘執行委員会のビンゴで使用する番号を管理するアプリです",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ja">
      <body
        className={`${geistSans.variable} ${geistMono.variable} ${notoSansJP.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="bingo-num-app/app/ver-1/components/common/ExportButtons.tsx">
"use client";

import React from "react";
import { prizeObjectType } from "@/app/ver-1/PrizeObjectType";

interface ExportButtonsProps {
  prizeNumList: prizeObjectType[];
  title?: string;
}

const ExportButtons: React.FC<ExportButtonsProps> = ({ prizeNumList, title = "bingo_results" }) => {
  // --- CSV生成 ---
  const downloadCSV = () => {
    if (!prizeNumList || prizeNumList.length === 0) {
      alert("エクスポートするデータがありません。");
      return;
    }

    const header: (keyof prizeObjectType)[] = ["prizeNum", "winnerNum", "isSelected", "isAnnounced", "memo"];
    const rows = prizeNumList.map((p) =>
      header
        .map((key) => {
          const val = p[key];
          const s = val === null || val === undefined ? "" : String(val);
          // カンマ・改行・ダブルクオートを含む場合はダブルクオートで囲む
          return s.includes(",") || s.includes("\n") || s.includes('"')
            ? `"${s.replace(/"/g, '""')}"`
            : s;
        })
        .join(",")
    );

    // UTF-8 with BOM（Excelでも文字化けしない）
    const csvContent = "\uFEFF" + [header.join(","), ...rows].join("\r\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const filename = `${title}_${ts}.csv`;

    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  return (
    <div className="flex gap-3">
      <button
        onClick={downloadCSV}
        className="border px-3 py-2 rounded bg-white hover:bg-gray-50"
      >
        CSVをダウンロード
      </button>
    </div>
  );
};

export default ExportButtons;
</file>

<file path="bingo-num-app/app/ver-1/components/common/ShowInfo.tsx">
"use client";

import { prizeObjectType } from "../../PrizeObjectType";

// Propsの型定義
interface ShowInfoProps {
    numOfPeople: number;
    numOfItems: number;
    prizeNumList: prizeObjectType[];
    mode: string;
}

// 番号選択画面（ビンゴ中）
const ShowInfo: React.FC<ShowInfoProps> = ({ numOfPeople, numOfItems, prizeNumList, mode }) => {
    // 残り景品数の変数（景品数 - 発表された景品番号の数）
    const restNumOfPrizes = numOfItems - prizeNumList.filter((item) => item.isSelected === true).length;
    const restNumOfAnnouncePrizes = numOfItems - prizeNumList.filter((item) => item.isAnnounced === true).length;

    return (
        <section className="grid grid-cols-3 gap-10">
            {/* 参加人数 */}
            <div className="flex flex-col gap-1 items-center py-2 border-2 border-gray-950/80 rounded-xl shadow-[0px_4px_6px_rgba(0,0,0,0.1)]">
                <span className="text-2xl">参加人数</span>
                <span className="text-xl">{numOfPeople}人</span>
            </div>
            {/* 景品数 */}
            <div className="flex flex-col gap-1 items-center py-2 border-2 border-gray-950/80 rounded-xl shadow-[0px_4px_6px_rgba(0,0,0,0.1)]">
                <span className="text-2xl">景品数</span>
                <span className="text-xl">{numOfItems}点</span>
            </div>
            {/* 残り景品数 */}
            <div className="flex flex-col gap-1 items-center py-2 border-2 border-gray-950/80 rounded-xl shadow-[0px_4px_6px_rgba(0,0,0,0.1)]">
                <span className="text-2xl">{mode === "progress" ? `残りの景品番号数` : `未発表の景品数`}</span>
                <span className="text-xl">{mode === "progress" ? `${restNumOfPrizes}` : `${restNumOfAnnouncePrizes}`}点</span>
            </div>
        </section>
    );
};
export default ShowInfo;
</file>

<file path="bingo-num-app/app/ver-1/components/item/AnnouncePrizeNumItem.tsx">
"use client";

import { prizeObjectType } from "../../PrizeObjectType";

// Propsの型
interface PrizeNumItemProps {
    item: prizeObjectType;
}

const AnnouncePrizeNumItem: React.FC<PrizeNumItemProps> = ({ item }) => {


    return (
        <button className={`min-h-25 min-w-30 flex flex-col gap-2 p-4 border-2 rounded-md shadow-[0_2px_4px_rgba(0,0,0,0.1)] ${item.isAnnounced ? "bg-yellow-200" : ""}`}>
            {item.isAnnounced ? (
                <>
                    <span className="text-xl">引換番号 : {item.prizeNum}<br />当選番号 : {item.winnerNum}</span>
                    <span>{item.memo}</span>
                </>
            ) : (
                <>
                    <span className="text-xl">引換番号 : {item.prizeNum}<br />当選番号 : ？</span>
                    <span>{item.memo}</span>
                </>
            )}
        </button>
    );
};
export default AnnouncePrizeNumItem;
</file>

<file path="bingo-num-app/app/ver-1/components/item/DisclosureItem.tsx">
"use client";

import { prizeObjectType } from "../../PrizeObjectType";

// Propsの型
interface PrizeNumItemProps {
    item: prizeObjectType;
    onAnnounce: (prizeNum: number) => void;
    onDisAnnounce: (prizeNum: number) => void;
}

const DisclosureItem: React.FC<PrizeNumItemProps> = ({ item, onAnnounce, onDisAnnounce }) => {
    // 選択状態を管理するコールバック関数
    const handleClick = () => onAnnounce(item.prizeNum);
    const handleDoubleClick = () => onDisAnnounce(item.prizeNum);

    return (
        <button onClick={handleClick} onDoubleClick={handleDoubleClick} className={`w-full max-w-3xl p-4 border-2 rounded-md shadow-[0_2px_4px_rgba(0,0,0,0.1)] ${item.isAnnounced ? "bg-yellow-200 cursor-not-allowed" : "hover:bg-gray-100 cursor-pointer"}`}>
            {item.isAnnounced ? (
                <>
                    <div>
                        <span className="text-xl">当選番号 : {item.winnerNum}</span>
                        <span className="text-xl ml-20">引換番号 : {item.prizeNum}</span>
                    </div>
                </>
            ) : (
                <>
                    <div className="w-full">
                        <span className="text-xl">当選番号 : {item.winnerNum}</span>
                        <span className="text-xl ml-20">引換番号 : ？</span>
                    </div>
                </>
            )}
        </button>
    );
};
export default DisclosureItem;
</file>

<file path="bingo-num-app/app/ver-1/components/item/PrizeNumItem.tsx">
"use client";

import { prizeObjectType } from "../../PrizeObjectType";
import Image from "next/image";
import edit_icon from "@/imges/edit_icon.svg";

// Propsの型
interface PrizeNumItemProps {
    item: prizeObjectType;
    onSelect: (prizeNum: number) => void;
    onDisSelect: (prizeNum: number) => void;
    onUpdateMemo: (prizeNum: number, memo: string) => void;
}

const PrizeNumItem: React.FC<PrizeNumItemProps> = ({ item, onSelect, onDisSelect, onUpdateMemo }) => {
    // 選択状態を管理するコールバック関数
    const handleClick = () => onSelect(item.prizeNum);
    const handleDoubleClick = () => onDisSelect(item.prizeNum);

    // メモ編集
    const handleMemoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        onUpdateMemo(item.prizeNum, e.target.value);
    };

    return (
        <button onClick={handleClick} onDoubleClick={handleDoubleClick} className={`min-h-25 min-w-30 flex flex-col gap-2 p-4 border-2 rounded-md shadow-[0_2px_4px_rgba(0,0,0,0.1)] ${item.isSelected ? "bg-gray-200 cursor-not-allowed" : "hover:bg-gray-100 cursor-pointer"}`}>
            {item.isSelected ? (
                <>
                    <span className="text-xl">{item.prizeNum} : 選択済み</span>
                    <div
                        className="flex gap-1 max-w-full"
                        // clickの伝播を留める
                        onClick={(e) => e.stopPropagation()}
                        onDoubleClick={(e) => e.stopPropagation()}
                    >
                        <label htmlFor={`memo-${item.prizeNum}`}>
                            <Image src={edit_icon} alt="メモ編集" width={20} height={20} />
                        </label>
                        <input type="text" id={`memo-${item.prizeNum}`} value={item.memo} onChange={handleMemoChange} className="max-w-[80%] border-2 border-gray-950/40 rounded-sm text-center focus:bg-white" />
                    </div>
                </>
            ) : (
                <>
                    <span className="text-xl">{item.prizeNum}</span>
                </>
            )}
        </button>
    );
};
export default PrizeNumItem;
</file>

<file path="bingo-num-app/app/ver-1/components/step/InAnnouncement.tsx">
"use client";

import { prizeObjectType } from "../../PrizeObjectType";
import AnnouncePrizeNumItem from "../item/AnnouncePrizeNumItem";
import ShowInfo from "../common/ShowInfo";
import ExportButtons from "../common/ExportButtons";
import DisclosureItem from "../item/DisclosureItem";

// Propsの型定義
interface InAnnouncementProps {
    numOfPeople: number;
    numOfItems: number;
    prizeNumList: prizeObjectType[];
    handleAnnounce: (prizeNum: number) => void;
    handleDisAnnounce: (prizeNum: number) => void;
}

// 番号選択画面（ビンゴ中）
const InAnnouncement: React.FC<InAnnouncementProps> = ({ numOfPeople, numOfItems, prizeNumList, handleAnnounce, handleDisAnnounce }) => {
    // 残り景品数の変数（景品数 - 発表された引換番号の数）
    const restPrizes = numOfItems - prizeNumList.filter((item) => item.isAnnounced === true).length;
    return (
        <div className="mt-6 flex flex-col h-screen">
            <div className="flex flex-col flex-[1_1_54%] border-b-2 border-gray-300 overflow-y-auto">
                <div className="sticky top-0 bg-white z-10">
                    <h2 className="text-2xl text-center font-bold">景品発表</h2>
                    {/* 進行情報表示 */}
                    <ShowInfo numOfPeople={numOfPeople} numOfItems={numOfItems} prizeNumList={prizeNumList} mode="announce" />
                </div>
                {/* 引換番号一覧 (引換番号〇, 当選番号✖, 引換番号順) */}
                <section className="mt-8 grid grid-cols-5 gap-8">
                    {prizeNumList.map((item: prizeObjectType) => (
                        // prizeNum はユニークなので key に指定
                        <AnnouncePrizeNumItem key={item.prizeNum} item={item} />
                    ))}
                </section>
                {restPrizes === 0 ? (
                    <div className="self-center flex flex-col items-center gap-2 mt-6">
                        <span className="text-3xl font-bold">参加していただき、</span>
                        <span className="text-3xl font-bold">ありがとうございました！</span>
                        <br />
                        <span className="text-xl font-bold">最後に、アンケートへのご協力をお願いします。</span>
                        <span className="text-xl font-bold">（スライドに戻ります...）</span>
                        <ExportButtons prizeNumList={prizeNumList} title="bingo_results" />
                    </div>
                ) : (
                    <div className="self-center mt-6"></div>
                )}
            </div>
            <div className="flex-[1_1_46%] overflow-y-auto  p-4">
                {/* 発表順リスト (引換番号✖, 当選番号〇, 当選番号順) */}
                <section className="mt-8 flex flex-col items-center gap-6">
                    {prizeNumList
                        .slice() // 元のリストの状態を破壊しないようにコピー
                        .sort((a, b) => b.winnerNum - a.winnerNum)              // 当選番号の降順（価値が低い順）
                        .sort((a, b) => a.displayOrderNum - b.displayOrderNum)  // 景品発表順 ※景品発表順を入れ替えてなければdisplayOrderNumは全て"0"
                        .map((item: prizeObjectType) => (
                            // prizeNum はユニークなので key に指定
                            <DisclosureItem key={item.prizeNum} item={item} onAnnounce={handleAnnounce} onDisAnnounce={handleDisAnnounce} />
                        ))}
                </section>
            </div>
        </div>
    );
};
export default InAnnouncement;
</file>

<file path="bingo-num-app/app/ver-1/components/step/InProgress.tsx">
"use client";

import { prizeObjectType } from "../../PrizeObjectType";
import ShowInfo from "../common/ShowInfo";
import PrizeNumItem from "../item/PrizeNumItem";

// Propsの型定義
interface InProgressProps {
    numOfPeople: number;
    numOfItems: number;
    prizeNumList: prizeObjectType[];
    handleSelect: (prizeNum: number) => void;
    handleDisSelect: (prizeNum: number) => void;
    handleUpdateMemo: (prizeNum: number, memo: string) => void;
    handleChangeAnnounce: () => void;
}

// 番号選択画面（ビンゴ中）
const InProgress: React.FC<InProgressProps> = ({ numOfPeople, numOfItems, prizeNumList, handleSelect, handleDisSelect, handleUpdateMemo, handleChangeAnnounce }) => {
    // 残り景品数の変数（景品数 - 選択された引換番号の数）
    const restPrizes = numOfItems - prizeNumList.filter((item) => item.isSelected === true).length;
    return (
        <div className="mt-6  flex flex-col gap-6">
            <h2 className="text-2xl text-center font-bold">番号選択</h2>
            {/* 進行情報表示 */}
            <ShowInfo numOfPeople={numOfPeople} numOfItems={numOfItems} prizeNumList={prizeNumList} mode="progress" />
            {/* 引換番号一覧 */}
            <section className="mt-8 grid grid-cols-5 gap-8 text-center">
                {prizeNumList.map((item: prizeObjectType) => (
                    // prizeNum はユニークなので key に指定
                    <PrizeNumItem key={item.prizeNum} item={item} onSelect={handleSelect} onDisSelect={handleDisSelect} onUpdateMemo={handleUpdateMemo} />
                ))}
            </section>
            {/* 景品発表へ移行するボタン（全て選択されるまでクリックできない） */}
            {restPrizes === 0 ? (
                <div className="self-center mt-6">
                    <button onClick={handleChangeAnnounce} className="border-2 p-4 rounded-2xl text-xl font-medium bg-yellow-200/50 hover:bg-yellow-200">景品発表へ移る</button>
                </div>
            ) : (
                <div className="self-center mt-6">
                    <button className="border-2 p-4 rounded-2xl text-xl font-medium bg-gray-200/50 hover:bg-gray-200 cursor-not-allowed">景品発表へ移る</button>
                </div>
            )}
        </div>
    );
};
export default InProgress;
</file>

<file path="bingo-num-app/app/ver-1/components/step/InputForm.tsx">
"use client";

import Image from "next/image";
import description_image from "@/imges/description_image.png"

// Propsの型定義
interface InputFormProps {
    numOfPeople: number;
    setNumOfPeople: React.Dispatch<React.SetStateAction<number>>;
    numOfItems: number;
    setNumOfItems: React.Dispatch<React.SetStateAction<number>>;
    isSelectAnnounceOrder: boolean;
    setIsSelectAnnounceOrder: React.Dispatch<React.SetStateAction<boolean>>;
    handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
}

// 情報入力セクション
const InputForm: React.FC<InputFormProps> = ({ numOfPeople, setNumOfPeople, numOfItems, setNumOfItems, isSelectAnnounceOrder, setIsSelectAnnounceOrder, handleSubmit }) => {
    return (
        <div className="flex flex-col">
            <form onSubmit={handleSubmit} className="mt-6  flex flex-col gap-6">
                <h2 className="text-3xl font-bold self-center">情報入力</h2>
                <section className="grid grid-cols-2 gap-10">
                    {/* 参加人数（値がNaNの時は空文字列を返すように） */}
                    <div className="flex flex-col items-center">
                        <label htmlFor="number_of_people" className="text-xl font-bold">
                            参加人数
                        </label>
                        <input type="number" id="number_of_people" name="number_of_people" placeholder="参加人数を入力" min={0} max={1000} required value={Number.isNaN(numOfPeople) ? "" : numOfPeople} onChange={(e) => setNumOfPeople(e.target.valueAsNumber)} className="border-2 text-center py-4 w-md text-xl" />
                    </div>
                    {/* 景品数（値がNaNの時は空文字列を返すように） */}
                    <div className="flex flex-col items-center">
                        <label htmlFor="number_of_items" className="text-xl font-bold">
                            景品数
                        </label>
                        <input type="number" id="number_of_items" name="number_of_items" placeholder="景品数を入力" min={0} max={1000} required value={Number.isNaN(numOfItems) ? "" : numOfItems} onChange={(e) => setNumOfItems(e.target.valueAsNumber)} className="border-2 text-center py-4 w-md text-xl" />
                    </div>
                </section>
                <section className="flex flex-col items-center gap-2">
                    <label htmlFor="select_announce_order" className="text-xl font-bold">景品発表順を入れ替える</label>
                    <input type="checkbox" id="select_announce_order" name="select_announce_order" checked={isSelectAnnounceOrder} onChange={(e: React.ChangeEvent<HTMLInputElement>) => setIsSelectAnnounceOrder(e.target.checked)}　 className="size-8 ms-2 text-sm font-medium text-gray-900" />
                </section>
                <button type="submit" className="my-4 mx-auto min-w-xs py-2.5 text-xl font-medium border-2 bg-gray-200/50 rounded-2xl hover:bg-gray-200">
                    決定
                </button>
            </form>
            <hr className="my-10 border-gray-950/50" />
            <h3 className="text-3xl font-bold text-center">このアプリについて</h3>
            <div className="self-center flex flex-col text-xl font-medium gap-2 mt-6">
                <span>このアプリは、ビンゴの当選番号周りの管理で人為的なミスを完全に防ぐために作成しました。</span>
                <br />
                <h4 className="text-2xl font-bold">アプリの概要</h4>
                <span>景品は1人につき最大1点当選<br />参加者数 ≧ 景品数 である場合でのみ処理を実行できます</span>
                <span>参加人数よりも景品数が多い場合、この場で比較的価値の低い景品から景品プールから超過分を除外します。<br />除外した景品は、次回以降のイベントに持ち越します。</span>
                <span></span>
                <span>もし、除外対象の景品を今回の景品に含めてほしいという要望があれば、景品プール内の景品と交換します。</span>
                <span>運営側の都合となり大変恐れ入りますが、<br />食品やシーズンアイテムは優先的に景品プールに含めさせていただきます。<br />高額景品や人気景品は必ず景品プールに含みます。</span>
                <br />
                <h4 className="text-2xl font-bold">主な変数について</h4>
                <span>景品id（現実）:<br />・1～景品総数<br />・数値が低いほど価値が高い。<br />・数値が高いほど比較的価値が低く、高い値から順に景品プールから除外される。<br />・景品idと参加者が選択する引換番号は連動していません。<br />・景品idと自動で割り当てられる当選番号は連動しています。</span>
                <span>参加人数:<br />・ビンゴに参加する人数の総数。<br />・ビンゴ開始前に必ず参加人数を再確認します。<br />・ビンゴ開始後の途中参加は不可能です。</span>
                <span>景品数:<br />・景品プール内に含む景品数<br />・必ず`参加者数 ≧ 景品数`となるよう調整。</span>
                <span>引換番号:<br />・1～景品プール内の景品数<br />・ビンゴした人は、一度だけ選択可能。</span>
                <span>当選番号:<br />・引換番号に対応してランダムに割り当てられる。<br />・景品発表の際に初めて判明する</span>
                <br />
                <h4 className="text-2xl font-bold">イメージ画像</h4>
                <div className="border-3">
                    <Image src={description_image} alt="イメージ画像" sizes="(max-width: 768px) 100vw, 50vw" className="flex-1 w-full h-auto object-cover"/>
                </div>
                <br />
                <h4 className="text-2xl font-bold">公平性について</h4>
                <span>当選番号を割り当てる処理には公平性を確保しています。<br />シャッフルに利用しているアルゴリズム: `Fisher-Yates shuffle`</span>
                <span>当選番号の処理に不正を疑う場合は、お手数をおかけしますがソースコードを解析してください。<br />ソースコードはGitHubのリポジトリ上で公開しています。</span>
                <a className="text-blue-600" href="https://github.com/takahiro-hirano67/ziyuu-sikkou-bingo-num.git">リポジトリへのリンク（GitHub）: https://github.com/takahiro-hirano67/ziyuu-sikkou-bingo-num.git</a>
            </div>
        </div>
    );
};
export default InputForm;
</file>

<file path="bingo-num-app/app/ver-1/components/step/SelectAnnounceOrder.tsx">
"use client";

import { DndContext, closestCenter, DragEndEvent } from "@dnd-kit/core";
import { SortableContext, useSortable, verticalListSortingStrategy } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { prizeObjectType } from "@/app/ver-1/PrizeObjectType";

interface Props {
    prizeNumList: prizeObjectType[];
    handleDragEnd: (event: DragEndEvent) => void;
    handleChangeInProgress: () => void;
}

export default function SelectAnnounceOrder({ prizeNumList, handleDragEnd, handleChangeInProgress }: Props) {
    return (
        <div className="flex flex-col gap-4">
            <h2 className="text-xl font-bold mt-10">景品発表順の設定</h2>
            <button onClick={handleChangeInProgress} className="my-4 mx-auto min-w-xs py-2.5 text-xl font-medium border-2 bg-gray-200/50 rounded-2xl hover:bg-gray-200">引換番号の選択へ進む</button>

            <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                <SortableContext items={prizeNumList.map((i) => i.prizeNum)} strategy={verticalListSortingStrategy}>
                    {prizeNumList.map((item) => (
                            <SortableItem key={item.prizeNum} item={item}  />
                        ))}
                </SortableContext>
            </DndContext>
        </div>
    );
}

function SortableItem({ item }: { item: prizeObjectType; }) {
    const { attributes, listeners, setNodeRef, transform, transition } = useSortable({
        id: item.prizeNum,
    });
    
    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
    };

    return (
        <div ref={setNodeRef} style={style} className="flex items-center justify-between bg-white border rounded-lg p-3 shadow-sm" {...attributes} {...listeners}>
            <span className="font-bold text-gray-700">当選番号: {item.winnerNum}</span>
            <div className="flex items-center gap-2">
                <span className="text-sm text-gray-500">発表順</span>
                <span>{item.displayOrderNum}</span>
            </div>
        </div>
    );
}
</file>

<file path="bingo-num-app/app/ver-1/layout.tsx">
export default function Layout({children}: {children: React.ReactNode}) {
    return (
        <section className="flex-1 w-full h-full min-w-screen min-h-screen bg-[#fefefe]">
            {children}
        </section>
    );
}
</file>

<file path="bingo-num-app/app/ver-1/page.tsx">
"use client";

import { useState } from "react";
import { useBeforeUnload } from "react-use";
import { DragEndEvent } from '@dnd-kit/core';
import { arrayMove } from '@dnd-kit/sortable';
import { prizeObjectType } from "./PrizeObjectType";
import InputForm from "./components/step/InputForm";
import InProgress from "./components/step/InProgress";
import InAnnouncement from "./components/step/InAnnouncement";
import SelectAnnounceOrder from "@/app/ver-1/components/step/SelectAnnounceOrder";

export default function MainPage() {
    // 基本入力情報
    const [numOfPeople, setNumOfPeople] = useState<number>(0);
    const [numOfItems, setNumOfItems] = useState<number>(0);
    const [isSelectAnnounceOrder, setIsSelectAnnounceOrder] = useState<boolean>(false);
    // // 引換番号管理
    const [prizeNumList, setPrizeNumList] = useState<prizeObjectType[]>([]);

    // アプリ状態管理
    const [step, setStep] = useState<"input" | "selectAnnounceOrder" | "inProgress" | "inAnnouncement">("input"); // 入力画面 | 引換番号選択画面 | 景品発表画面
    const [isProgress, setIsProgress] = useState<boolean>(false); // 誤リロード防止用

    // 誤リロード防止処理（リロードやページを閉じようとしたらアラートが出現）
    useBeforeUnload(isProgress);

    // リスト内の要素をランダムに入れ替える関数（公平性重視...フィッシャー・イェーツのシャッフルアルゴリズム: Fisher–Yates shuffle）
    const shuffleArray = (array: number[]) => {
        for (let i = array.length - 1; i > 0; i--) {
            // 0からiまでのランダムなインデックスを生成
            const j = Math.floor(Math.random() * (i + 1));
            // 分割代入を使って要素を交換
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    };

    // ============================================================
    // 基本情報入力完了時の処理
    // ============================================================

    const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        console.log(isSelectAnnounceOrder)
        // 入力値が0以下 もしくは NaNの時は処理を実行しない
        if (numOfItems <= 0 || Number.isNaN(numOfItems) || numOfPeople <= 0 || Number.isNaN(numOfPeople)) {
            alert("不正な値、もしくは入力されていません");
            return;
        }
        // 景品数が参加者数よりも多い場合は処理を実行しない（参加者の前で除外する景品を公表する）
        if (numOfItems > numOfPeople) {
            alert(
                "景品数が参加者数よりも多い状態です。景品数を減らしてください。\n```進行例:\n今回は想定よりも参加人数が少ないため、\n景品数を参加人数に合わせます。\nそして、比較的に価値の低い景品は景品プールから除外し、\n次回以降のイベントに持ち越します。\n除外する景品の中で、今回のビンゴの景品に含めたいものはありますか？\n（もし希望があれば景品を入れ替える）\n運営側の都合となり恐れ入りますが、食品やシーズンアイテムは優先的に\n景品プールに含めさせていただきます。\n```"
            );
            return;
        }
        setIsProgress(true);

        // 景品の数だけ引換番号を生成する
        const originalList: number[] = [];
        for (let i = 1; i <= numOfItems; i++) {
            originalList.push(i);
        }
        // 景品の数に対応した当選番号を生成する
        const ShuffledList: number[] = shuffleArray(originalList.slice());

        // 引換番号と当選番号を対応付けたオブジェクトを生成
        const prizeObject: prizeObjectType[] = originalList.map((prizeNum, i) => ({
            prizeNum,
            winnerNum: ShuffledList[i],
            displayOrderNum: 0,
            isSelected: false,
            isAnnounced: false,
            memo: "",
        }));

        setPrizeNumList(prizeObject); // 引換番号のリストを更新

        // 景品発表順の選択画面
        if (isSelectAnnounceOrder === true) {
            // 並び替え画面を使う場合のみ「降順ソート」して見やすく
            const sortedPrizeObject = prizeObject
                .slice()
                .sort((a, b) => b.winnerNum - a.winnerNum)
                .map((item, index) => ({
                    ...item,
                    displayOrderNum: index + 1,
                }));
            setPrizeNumList(sortedPrizeObject);
            setStep("selectAnnounceOrder")
        }
        // 引換番号選択画面
        else {
            // ソートなし（デフォルト：引換番号順 ※当選番号はランダム）
            setStep("inProgress");
        }
    };

    // ============================================================
    // 画面移行時の処理
    // ============================================================

    const handleChangeInProgress = () => {
        if (window.confirm("引換番号の選択に移ります。よろしいですか？")) {
            // 「はい」を選択した場合の処理
            // デフォルトの並び順（引換番号順）に戻す
            const defaultSortedList = [...prizeNumList].sort((a, b) => a.prizeNum - b.prizeNum);
            setPrizeNumList(defaultSortedList)
            setStep("inProgress");
        } else {
            // 「いいえ」を選択した場合の処理
            return;
        }
    }

    const handleChangeAnnouncement = () => {
        if (window.confirm("景品発表へ移ります。よろしいですか？\n確認事項:\n・引換番号は全て配布しているか？\n・未選択の引換番号はないか？")) {
            // 「はい」を選択した場合の処理
            setStep("inAnnouncement");
        } else {
            // 「いいえ」を選択した場合の処理
            return;
        }
    };

    // ============================================================
    // 引換番号の要素に対する処理（番号選択時）
    // ============================================================

    // 引換番号をクリックすると選択済み
    const handleSelect = (prizeNum: number) => {
        setPrizeNumList((prev) => prev.map((item) => (item.prizeNum === prizeNum ? { ...item, isSelected: true } : item)));
    };
    // 引換番号をダブルクリックすると選択状態を解除（保険機能）
    const handleDisSelect = (prizeNum: number) => {
        alert("選択状態を解除しました");
        setPrizeNumList((prev) => prev.map((item) => (item.prizeNum === prizeNum ? { ...item, isSelected: false } : item)));
    };
    // メモ欄を更新する関数
    const handleUpdateMemo = (prizeNum: number, memo: string) => {
        setPrizeNumList((prev) => prev.map((item) => (item.prizeNum === prizeNum ? { ...item, memo } : item)));
    };


    // ============================================================
    // 引換番号の要素に対する処理（景品発表時）
    // ============================================================

    // 引換番号をクリックすると選択済み
    const handleAnnounce = (prizeNum: number) => {
        setPrizeNumList((prev) => prev.map((item) => (item.prizeNum === prizeNum ? { ...item, isAnnounced: true } : item)));
    };
    // 引換番号をダブルクリックすると選択状態を解除（保険機能）
    const handleDisAnnounce = (prizeNum: number) => {
        alert("発表状態を解除しました");
        setPrizeNumList((prev) => prev.map((item) => (item.prizeNum === prizeNum ? { ...item, isAnnounced: false } : item)));
    };


    // ============================================================
    // 景品発表順を並べ替える処理
    // ============================================================

    function handleDragEnd(event: DragEndEvent) {
        const { active, over } = event;

        if (over && active.id !== over.id) {
            setPrizeNumList((items) => {
                const oldIndex = items.findIndex(item => item.prizeNum === active.id);  // active.id → ドラッグ元
                const newIndex = items.findIndex(item => item.prizeNum === over.id);    // over.id → ドロップ先

                // 配列を並べ替える
                const newOrderedItems = arrayMove(items, oldIndex, newIndex);

                // 必要であれば、ここで index プロパティの番号も振り直す
                return newOrderedItems.map((item, index) => ({
                    ...item,
                    displayOrderNum: index + 1
                }));
            });
        }
    }

    // ============================================================
    // 要素表示
    // ============================================================

    return (
        <div className="p-8">
            <h1 className="fixed z-20 text-2xl font-bold">ビンゴ番号管理アプリ</h1>
            <main className="mx-auto mt-4 max-w-5xl">
                {/* 参加人数と景品数を入力するフォーム */}
                {step === "input" && <InputForm numOfPeople={numOfPeople} setNumOfPeople={setNumOfPeople} numOfItems={numOfItems} setNumOfItems={setNumOfItems} isSelectAnnounceOrder={isSelectAnnounceOrder} setIsSelectAnnounceOrder={setIsSelectAnnounceOrder} handleSubmit={handleSubmit} />}
                {/* 景品発表順を選択する画面 */}
                {step === "selectAnnounceOrder" && <SelectAnnounceOrder prizeNumList={prizeNumList} handleDragEnd={handleDragEnd} handleChangeInProgress={handleChangeInProgress} />}
                {/* 引換番号選択画面 */}
                {step === "inProgress" && <InProgress numOfPeople={numOfPeople} numOfItems={numOfItems} prizeNumList={prizeNumList} handleSelect={handleSelect} handleDisSelect={handleDisSelect} handleUpdateMemo={handleUpdateMemo} handleChangeAnnounce={handleChangeAnnouncement} />}
                {/* 景品発表画面 */}
                {step === "inAnnouncement" && <InAnnouncement numOfPeople={numOfPeople} numOfItems={numOfItems} prizeNumList={prizeNumList} handleAnnounce={handleAnnounce} handleDisAnnounce={handleDisAnnounce} />}
            </main>
        </div>
    );
}
</file>

<file path="bingo-num-app/app/ver-1/PrizeObjectType.ts">
// 景品番号オブジェクトの型定義
export type prizeObjectType = {
    prizeNum: number;           // 景品番号
    winnerNum: number;          // 当選番号
    displayOrderNum: number;    // 発表順
    isSelected: boolean;        // 景品番号を選択したかどうか
    isAnnounced: boolean;       // 景品を発表したかどうか
    memo: string;               // メモ
};
</file>

<file path="bingo-num-app/app/ver-1/README.md">
# bingo-num-app

## このアプリについて

このアプリは、ビンゴの当選番号周りの管理で人為的なミスを完全に防ぐために作成しました。

---

### アプリの概要

* 景品は1人につき最大1点当選
* 参加者数 ≧ 景品数 である場合でのみ処理を実行できます
* 参加人数よりも景品数が多い場合、この場で比較的価値の低い景品から景品プールから超過分を除外します。
  除外した景品は、次回以降のイベントに持ち越します。

もし、除外対象の景品を今回の景品に含めてほしいという要望があれば、景品プール内の景品と交換します。

運営側の都合となり大変恐れ入りますが、
食品やシーズンアイテムは優先的に景品プールに含めさせていただきます。
高額景品や人気景品は必ず景品プールに含みます。

---

### 主な変数について

**景品id（現実）:**

* 1～景品総数
* 数値が低いほど価値が高い
* 数値が高いほど比較的価値が低く、高い値から順に景品プールから除外される
* 景品idと参加者が選択する景品番号は連動していない
* 景品idと自動で割り当てられる当選番号は連動している

**参加人数:**

* ビンゴに参加する人数の総数
* ビンゴ開始前に必ず参加人数を再確認する
* ビンゴ開始後の途中参加は不可能

**景品数:**

* 景品プール内に含む景品数
* 必ず `参加者数 ≧ 景品数` となるよう調整

**景品番号:**

* 1～景品プール内の景品数
* ビンゴした人は一度だけ選択可能

**当選番号:**

* 景品番号に対応してランダムに割り当てられる
* 景品発表の際に初めて判明する

---

### イメージ画像1

人数と景品数

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/ba3ab150-69fd-449d-94f2-51daf40ed50b" />

---
### イメージ画像2

景品idと景品番号＆当選番号

![Image](https://github.com/user-attachments/assets/d9384ea7-c268-4fcd-bfe2-77d7ccc3a08e)

---

### 公平性について

当選番号を割り当てる処理には公平性を確保しています。
シャッフルに利用しているアルゴリズム: `Fisher-Yates shuffle`

当選番号の処理に不正を疑う場合は、お手数をおかけしますがソースコードを解析してください。
ソースコードはGitHubのリポジトリ上で公開しています。

[リポジトリへのリンク（GitHub）](https://github.com/takahiro-hirano67/ziyuu-sikkou-bingo-num.git)

---

### デメリット（現行の仕様）

* 1人2点当選がほぼ不可能
* 参加者数 ＜ 景品数　の場合参加者の目の前で景品を除外する必要がある

---
### 従来の流れと問題点
イベントの参加人数 > 景品数 の場合は何も気にすることはない。

しかし、イベントの参加人数 < 景品数 となる場合が多い。
この時、運営側としては目玉景品や食品系を確実に排出しておきたい。

従来は手動でランダムな当選番号を挿入していた。
そして、参加人数に応じた景品番号を 10人参加の場合の景品番号, 11人参加の場合の景品番号... のように個別で割り当てていた。

ただし、当日の人数が想定以上に少なかった場合、対応できないケースが出てくる。
本番その場で景品番号を割り当てていたり、そもそも景品番号を設定する箇所が多く、ミスは防ぎきれない。

→プログラムで公平に、そして確実にミスを防げるよう管理したい。

### アプローチ:
イベントの参加人数 >= 景品数 の場合は情報を適切に入力して実行。
イベントの参加人数 < 景品数 となる場合は、本番その場で景品数===参加者数に合わせる。

この時、参加者の前で 「今回は想定よりも参加人数が少ないため、価値の低いビンゴの景品は次回以降のイベントに持ち越す。
これらの景品の中で、今回のビンゴの景品に含めたいものはありますか？」と確認を取り、景品プールから除外する。

こうすることで、イベントの参加人数 < 景品数　は物理的に発生することはない。

起こり得る状況 参加者数 > 景品数 --> 正常 参加者数 === 景品数 --> 物理的に合わせる
</file>

<file path="bingo-num-app/app/ver-2/page.tsx">
"use client";

import React, { useState, useMemo } from 'react';
import { useBeforeUnload } from "react-use"; // 誤リロード防止用
// DND-Kit ライブラリのインポート
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { arrayMove, SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
// Heroicons ライブラリのインポート（アイコン用）
import { TrashIcon, ArrowUturnLeftIcon, Bars3Icon, CheckIcon } from '@heroicons/react/24/outline';

// --- 型定義 ---

/**
 * 景品オブジェクトの型
 */
type PrizeObject = {
  id: string; // dnd-kit用の一意のID
  prizeName: string; // 景品名
  prizeNum: number | null; // 景品番号 (引換番号)
  displayOrderNum: number; // 景品発表順
  isSelected: boolean; // 景品番号が選択されたか (Step 3)
  isAnnounced: boolean; // 景品が発表されたか (Step 4)
  isExcluded: boolean; // 景品が除外されたか (Step 2)
  memo: string; // メモ (Step 3)
};

/**
 * アプリの現在のステップを示す型
 */
type Step = "prizeInput" | "peopleInput" | "selectPrizeNum" | "AnnouncePrize";

// --- ユーティリティ関数 ---

/**
 * Fisher-Yates (Knuth) シャッフルアルゴリズム
 * 配列をランダムに並べ替えるために使用します。
 * @param array シャッフル対象の配列
 * @returns シャッフル後の新しい配列
 */
const fisherYatesShuffle = <T,>(array: T[]): T[] => {
  const newArray = [...array]; // 元の配列をコピー
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    // ES6の分割代入を使用して要素を交換
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};


// --- メインコンポーネント (app/page.tsx) ---

export default function Home() {
  // アプリの現在のステップを管理
  const [currentStep, setCurrentStep] = useState<Step>("prizeInput");
  // すべての景品オブジェクトのリストを管理
  const [prizeObjectList, setPrizeObjectList] = useState<PrizeObject[]>([]);
  // 参加人数を管理
  const [numberOfPeople, setNumberOfPeople] = useState<number>(0);

  // アプリの状態管理
  const [isProgress, setIsProgress] = useState<boolean>(false); // 誤リロード防止用

  // 誤リロード防止処理（リロードやページを閉じようとしたらアラートが出現）
  useBeforeUnload(isProgress);

  /**
   * アプリの状態を初期化（リセット）する関数
   */
  const resetApp = () => {
    // ユーザーに確認
    if (window.confirm("最初からやり直しますか？すべてのデータがリセットされます。")) {
      setCurrentStep("prizeInput");
      setPrizeObjectList([]);
      setNumberOfPeople(0);
      setIsProgress(false);
    }
  };

  // --- 計算済みプロパティ (useMemoでパフォーマンス最適化) ---

  // 除外されていない景品（有効な景品）のリスト
  const activePrizes = useMemo(
    () => prizeObjectList.filter((prize) => !prize.isExcluded),
    [prizeObjectList]
  );
  
  // 有効な景品数
  const numberOfActivePrizes = activePrizes.length;

  /**
   * 現在のステップに応じて表示するコンポーネントを切り替える
   */
  const renderStep = () => {
    switch (currentStep) {
      case "prizeInput":
        return (
          <PrizeInputStep
            setIsProgress={setIsProgress}
            setPrizeObjectList={setPrizeObjectList}
            setCurrentStep={setCurrentStep}
          />
        );
      case "peopleInput":
        return (
          <PeopleInputStep
            prizeObjectList={prizeObjectList}
            setPrizeObjectList={setPrizeObjectList}
            numberOfPeople={numberOfPeople}
            setNumberOfPeople={setNumberOfPeople}
            setCurrentStep={setCurrentStep}
            activePrizes={activePrizes}
            numberOfActivePrizes={numberOfActivePrizes}
          />
        );
      case "selectPrizeNum":
        return (
          <SelectPrizeNumStep
            prizeObjectList={prizeObjectList}
            setPrizeObjectList={setPrizeObjectList}
            numberOfPeople={numberOfPeople}
            setCurrentStep={setCurrentStep}
            activePrizes={activePrizes}
            numberOfActivePrizes={numberOfActivePrizes}
          />
        );
      case "AnnouncePrize":
        return (
          <AnnouncePrizeStep
            prizeObjectList={prizeObjectList}
            setPrizeObjectList={setPrizeObjectList}
            numberOfPeople={numberOfPeople}
            activePrizes={activePrizes}
            numberOfActivePrizes={numberOfActivePrizes}
          />
        );
      default:
        return null;
    }
  };

  // --- レンダリング ---
  return (
    <main className="flex min-h-screen flex-col items-center justify-start p-6 md:px-12 md:py-6 lg:px-24 lg:py-6 bg-gray-50 font-sans text-gray-900">
      {/* --- ヘッダー --- */}
      <div className="z-10 w-full max-w-4xl items-center justify-between lg:flex mb-4">
        <h1 className="text-3xl font-bold text-gray-800 tracking-tight">
          景品番号管理アプリ
        </h1>
        {/* リセットボタン */}
        <button
          onClick={resetApp}
          className="flex items-center gap-2 mt-4 lg:mt-0 px-4 py-2 bg-red-500 text-lg text-white rounded-lg shadow-md hover:bg-red-600 transition-colors duration-200"
        >
          <ArrowUturnLeftIcon className="w-5 h-5" />
          リセット
        </button>
      </div>
      
      {/* --- メインコンテンツ（ステップごと） --- */}
      <div className="w-full max-w-4xl bg-white rounded-xl shadow-2xl overflow-hidden">
        {renderStep()}
      </div>
      
      {/* --- フッター --- */}
      <footer className="mt-10 text-center text-gray-500 text-sm">
        <p>愛知工業大学 自由ヶ丘執行委員会</p>
      </footer>
    </main>
  );
}


// --- ステップ1：景品入力コンポーネント ---
interface PrizeInputStepProps {
  setIsProgress: React.Dispatch<React.SetStateAction<boolean>>;
  setPrizeObjectList: React.Dispatch<React.SetStateAction<PrizeObject[]>>;
  setCurrentStep: React.Dispatch<React.SetStateAction<Step>>;
}

function PrizeInputStep({ setPrizeObjectList, setCurrentStep, setIsProgress }: PrizeInputStepProps) {
  // テキストエリアの入力値を管理
  const [prizeInputText, setPrizeInputText] = useState("");

  // テキストエリアの入力に基づいて現在の景品リスト（文字列配列）を計算
  const currentPrizes = useMemo(() => {
    // 改行で分割し、空行を除去
    return prizeInputText.split('\n').filter(name => name.trim() !== '');
  }, [prizeInputText]);
  
  // 現在の景品数
  const currentPrizeCount = currentPrizes.length;

  /**
   * 決定ボタン押下時の処理
   */
  const handleSubmit = () => {
    if (currentPrizeCount === 0) {
      alert("景品を1つ以上入力してください。");
      return;
    }
    
    // 景品オブジェクトの配列を生成
    const newPrizeObjectList: PrizeObject[] = currentPrizes.map((name, index) => ({
      id: crypto.randomUUID(), // dnd-kit用の一意ID
      prizeName: name.trim(),
      prizeNum: null,
      displayOrderNum: index + 1, // 発表順（入力順で初期化）
      isSelected: false,
      isAnnounced: false,
      isExcluded: false,
      memo: "",
    }));
    setIsProgress(true); // アプリ処理開始（以降はリロードやページを閉じようとした際に確認アラートが発生）
    setPrizeObjectList(newPrizeObjectList);
    setCurrentStep("peopleInput"); // 次のステップへ
  };

  return (
    <div className="p-6 md:p-8">
      <h2 className="text-2xl font-semibold text-gray-700 mb-2">Step 1: 景品入力</h2>
      <p className="text-lg text-gray-600 mb-6">景品名を1行に1つずつ入力してください。<br />（メモ帳などからのコピー＆ペーストを推奨します）</p>
      
      {/* 現在の景品数を表示 */}
      <div className="flex justify-between items-center mb-4 p-4 bg-gray-100 rounded-lg">
        <span className="text-xl font-medium text-gray-800">
          現在の景品数: <span className="text-blue-600 text-2xl font-bold">{currentPrizeCount}</span>
        </span>
      </div>
      
      {/* 景品入力テキストエリア */}
      <textarea
        value={prizeInputText}
        onChange={(e) => setPrizeInputText(e.target.value)}
        rows={15}
        className="w-full p-4 text-lg border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"
        placeholder={"例：\n旅行券\nワイヤレスイヤホン\nモバイルバッテリー\n・\n・\n・"} />
      
      {/* 決定ボタン */}
      <div className="mt-8 text-center">
        <button
          onClick={handleSubmit}
          disabled={currentPrizeCount === 0} // 景品が0の場合は無効
          className="px-8 py-3 bg-blue-600 text-white text-lg font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          参加人数入力へ進む
        </button>
      </div>
    </div>
  );
}


// --- ステップ2：参加人数入力 & 景品数調整コンポーネント ---
interface PeopleInputStepProps {
  prizeObjectList: PrizeObject[];
  setPrizeObjectList: React.Dispatch<React.SetStateAction<PrizeObject[]>>;
  numberOfPeople: number;
  setNumberOfPeople: React.Dispatch<React.SetStateAction<number>>;
  setCurrentStep: React.Dispatch<React.SetStateAction<Step>>;
  activePrizes: PrizeObject[]; // 有効な景品リスト
  numberOfActivePrizes: number; // 有効な景品数
}

function PeopleInputStep({
  prizeObjectList,
  setPrizeObjectList,
  numberOfPeople,
  setNumberOfPeople,
  setCurrentStep,
  activePrizes,
  numberOfActivePrizes
}: PeopleInputStepProps) {
  
  // 除外された景品数
  const excludedPrizesCount = prizeObjectList.length - numberOfActivePrizes;
  
  // 決定ボタンを押せるかどうかの条件（参加人数 ≧ 景品数, かつ景品数 > 0, かつ参加人数 > 0）
  const canProceed = numberOfPeople >= numberOfActivePrizes && numberOfActivePrizes > 0 && numberOfPeople > 0;

  // dnd-kit センサーの初期化（ポインターとキーボード）
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  /**
   * 景品の「除外」「復元」をトグルする
   * @param id トグル対象の景品ID
   */
  const toggleExcludePrize = (id: string) => {
    setPrizeObjectList(prevList => {
      // 対象の景品のisExcludedを反転
      const newList = prevList.map(prize => 
        prize.id === id ? { ...prize, isExcluded: !prize.isExcluded } : prize
      );
      // 発表順（displayOrderNum）を更新
      // （並べ替えロジックと競合するため、ここでは順序は変更しない）
      return newList;
    });
  };
  
  /**
   * ドラッグ＆ドロップ終了時の処理
   * @param event DNDイベント
   */
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setPrizeObjectList((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        
        // arrayMoveで並べ替え後、displayOrderNumをインデックスに基づいて再割り当て
        return arrayMove(items, oldIndex, newIndex).map((item, index) => ({
          ...item,
          displayOrderNum: index + 1,
        }));
      });
    }
  };

  /**
   * 決定ボタン（景品番号の割り当て）押下時の処理
   */
  const handleSubmit = () => {
    if (!canProceed) {
      alert("参加人数が景品数（除外を除く）以上になるように設定してください。");
      return;
    }
    
    // 1. 有効な景品リスト (activePrizes は props から取得)
    
    // 2. 景品番号リスト [1, 2, ..., numOfItems] を生成
    const prizeNumbers = Array.from({ length: numberOfActivePrizes }, (_, i) => i + 1);
    
    // 3. 有効な景品リストをシャッフル
    const shuffledPrizes = fisherYatesShuffle(activePrizes);
    
    // 4. シャッフルした景品に景品番号を割り当て (高速化のためMap使用)
    const prizedMap = new Map<string, number>();
    shuffledPrizes.forEach((prize, index) => {
      prizedMap.set(prize.id, prizeNumbers[index]);
    });
    
    // 5. 元のリスト（prizeObjectList）を更新
    setPrizeObjectList(prevList => 
      prevList.map(prize => {
        // MapにIDが存在（＝有効な景品）なら、景品番号を設定
        if (prizedMap.has(prize.id)) {
          return { ...prize, prizeNum: prizedMap.get(prize.id)! };
        }
        return prize; // 除外された景品は prizeNum: null のまま
      })
    );
    
    setCurrentStep("selectPrizeNum"); // 次のステップへ
  };

  return (
    <div className="p-6 md:p-8">
      <h2 className="text-2xl font-semibold text-gray-700 mb-4">Step 2: 参加人数入力 & 景品調整</h2>
      
      {/* --- 上部：入力欄 --- */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-4 p-6 bg-gray-100 rounded-lg">
        {/* 参加人数入力 */}
        <div>
          <label htmlFor="peopleInput" className="block text-xl font-medium text-gray-700 mb-1">
            参加人数
          </label>
          <input
            id="peopleInput"
            type="number"
            min={0}
            value={numberOfPeople === 0 ? '' : numberOfPeople} // 0の場合は空表示
            onChange={(e) => setNumberOfPeople(Math.max(0, parseInt(e.target.value) || 0))}
            className="w-full p-3 text-lg border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-blue-500"
            placeholder="例: 10"
          />
        </div>
        {/* 有効な景品数 */}
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-lg font-medium text-gray-500">現在の景品数 (有効)</span>
          <span className="text-2xl font-bold text-blue-600">{numberOfActivePrizes}</span>
        </div>
        {/* 除外した景品数 */}
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-lg font-medium text-gray-500">除外した景品数</span>
          <span className="text-2xl font-bold text-gray-600">{excludedPrizesCount}</span>
        </div>
      </div>
      
      {/* --- 警告メッセージ --- */}
      {!canProceed && (
        <div className="mb-4 p-4 text-lg bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 rounded-lg">
          <p className="font-semibold">
            {numberOfPeople <= 0 ? "参加人数を入力してください。" : "参加人数が有効な景品数以上である必要があります。"}
          </p>
          <p className="text-md">
            （ 現在：{numberOfPeople} (参加人数) vs {numberOfActivePrizes} (景品数) ）
          </p>
        </div>
      )}

      {/* --- 下部：景品リスト (DND) --- */}
      <h3 className="text-xl font-semibold text-gray-700 mb-2">景品リスト (発表順)</h3>
      <p className="text-md text-gray-500 mb-4">ドラッグ&ドロップで発表順を変更できます。参加人数より景品が多い場合は「除外」してください。</p>
      
      <div className="max-h-96 overflow-y-auto border border-gray-200 rounded-lg">
        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
        >
          <SortableContext
            items={prizeObjectList.map(p => p.id)} // IDの配列を渡す
            strategy={verticalListSortingStrategy} // 垂直方向のソート
          >
            <ul className="divide-y divide-gray-200">
              {/* 発表順（displayOrderNum）でソートして表示 */}
              {prizeObjectList
                .sort((a, b) => a.displayOrderNum - b.displayOrderNum)
                .map((prize) => (
                  <SortablePrizeItem
                    key={prize.id}
                    prize={prize}
                    toggleExcludePrize={toggleExcludePrize}
                  />
              ))}
            </ul>
          </SortableContext>
        </DndContext>
      </div>

      {/* --- 決定ボタン --- */}
      <div className="mt-6">
        <button
          onClick={handleSubmit}
          disabled={!canProceed} // 条件を満たさないと無効
          className="flex items-center gap-2 float-right px-8 py-3 mb-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          <CheckIcon className="w-5 h-5" />
          景品番号を割り当て
        </button>
      </div>
    </div>
  );
}

/**
 * Step 2用：並べ替え可能な景品リストアイテム
 */
function SortablePrizeItem({ prize, toggleExcludePrize }: { prize: PrizeObject; toggleExcludePrize: (id: string) => void; }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
  } = useSortable({ id: prize.id }); // IDで紐付け
  
  // ドラッグ&ドロップ中のスタイル
  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  const isExcluded = prize.isExcluded;

  return (
    <li
      ref={setNodeRef} // ドラッグ&ドロップノード参照
      style={style}
      className={`flex items-center justify-between p-4 ${isExcluded ? 'bg-gray-200 opacity-60' : 'bg-white'}`}
    >
      <div className="flex items-center gap-4">
        {/* ドラッグハンドル */}
        <button
          {...attributes} // DND属性
          {...listeners} // DNDリスナー
          className={`cursor-grab touch-none p-2 rounded ${isExcluded ? 'text-gray-500 cursor-not-allowed' : 'text-gray-400 hover:bg-gray-100'}`}
          disabled={isExcluded} // 除外中はDND不可
        >
          <Bars3Icon className="w-5 h-5" />
        </button>
        {/* 発表順 と 景品名 */}
        <span className={`text-lg font-medium ${isExcluded ? 'text-gray-600 line-through' : 'text-gray-800'}`}>
          {prize.displayOrderNum}. {prize.prizeName}
        </span>
      </div>
      {/* 除外/復元ボタン */}
      <button
        onClick={() => toggleExcludePrize(prize.id)}
        className={`flex items-center gap-1.5 px-3 py-1.5 rounded-md text-sm font-medium transition-colors ${
          isExcluded
            ? 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200'
            : 'bg-red-100 text-red-700 hover:bg-red-200'
        }`}
      >
        {isExcluded ? <ArrowUturnLeftIcon className="w-4 h-4" /> : <TrashIcon className="w-4 h-4" />}
        {isExcluded ? '復元' : '除外'}
      </button>
    </li>
  );
}


// --- ステップ3：景品番号選択コンポーネント ---
interface SelectPrizeNumStepProps {
  prizeObjectList: PrizeObject[];
  setPrizeObjectList: React.Dispatch<React.SetStateAction<PrizeObject[]>>;
  numberOfPeople: number;
  setCurrentStep: React.Dispatch<React.SetStateAction<Step>>;
  activePrizes: PrizeObject[];
  numberOfActivePrizes: number;
}

function SelectPrizeNumStep({
  setPrizeObjectList,
  numberOfPeople,
  setCurrentStep,
  activePrizes,
  numberOfActivePrizes
}: SelectPrizeNumStepProps) {
  
  // 選択済みの景品数
  const selectedPrizesCount = activePrizes.filter(p => p.isSelected).length;
  // 残りの未選択の景品数
  const remainingPrizesCount = numberOfActivePrizes - selectedPrizesCount;
  // 全て選択済みか
  const allPrizesSelected = remainingPrizesCount === 0;

  /**
   * 景品番号をクリック（選択）
   * @param prizeNum 選択された景品番号
   */
  const handleSelectPrize = (prizeNum: number) => {
    setPrizeObjectList(prevList => 
      prevList.map(prize => 
        prize.prizeNum === prizeNum ? { ...prize, isSelected: true } : prize
      )
    );
  };
  
  /**
   * 景品番号をダブルクリック（選択解除）
   * @param prizeNum 解除された景品番号
   */
  const handleDeselectPrize = (prizeNum: number) => {
    setPrizeObjectList(prevList => 
      prevList.map(prize => 
        prize.prizeNum === prizeNum ? { ...prize, isSelected: false, memo: "" } : prize // メモもリセット
      )
    );
  };
  
  /**
   * メモ欄の更新
   * @param prizeNum 対象の景品番号
   * @param memo 入力されたメモ
   */
  const handleMemoChange = (prizeNum: number, memo: string) => {
    setPrizeObjectList(prevList => 
      prevList.map(prize => 
        prize.prizeNum === prizeNum ? { ...prize, memo: memo } : prize
      )
    );
  };

  // 景品番号順にソートされた有効な景品リスト（グリッド表示用）
  const sortedActivePrizes = useMemo(() => {
    return [...activePrizes].sort((a, b) => (a.prizeNum || 0) - (b.prizeNum || 0));
  }, [activePrizes]);

  return (
    <div className="p-6 md:p-8">
      <h2 className="text-2xl font-semibold text-gray-700 mb-2">Step 3: 景品番号選択</h2>
      <p className="text-gray-600 text-lg mb-4">ビンゴした人が引換番号を選択します。クリックで選択、ダブルクリックで解除できます。</p>

      {/* --- 上部：情報 --- */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6 p-4 bg-gray-100 rounded-lg">
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-md font-medium text-gray-500">参加人数</span>
          <span className="text-2xl font-bold text-gray-800">{numberOfPeople}</span>
        </div>
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-md font-medium text-gray-500">景品数</span>
          <span className="text-2xl font-bold text-blue-600">{numberOfActivePrizes}</span>
        </div>
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-md font-medium text-gray-500">残り (未選択)</span>
          <span className={`text-2xl font-bold ${remainingPrizesCount > 0 ? 'text-red-600' : 'text-green-600'}`}>
            {remainingPrizesCount}
          </span>
        </div>
      </div>
      
      {/* --- 中部：景品番号グリッド --- */}
      <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
        {sortedActivePrizes.map(prize => (
          <PrizeNumberBox
            key={prize.id}
            prize={prize}
            onSelect={handleSelectPrize}
            onDeselect={handleDeselectPrize}
            onMemoChange={handleMemoChange}
          />
        ))}
      </div>
      
      {/* --- 警告メッセージ --- */}
      {!allPrizesSelected && (
        <div className="mt-6 p-4 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 rounded-lg">
          <p className="font-semibold">
            すべての景品が選択されると、景品発表に移れます。
          </p>
        </div>
      )}

      {/* --- 下部：決定ボタン --- */}
      <div className="mt-8 text-right">
        <button
          onClick={() => setCurrentStep("AnnouncePrize")}
          disabled={!allPrizesSelected} // 全て選択されるまで無効
          className="px-8 py-3 bg-green-600 text-lg text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          景品発表へ移る
        </button>
      </div>
    </div>
  );
}

/**
 * Step 3用：景品番号ボックス
 */
function PrizeNumberBox({ prize, onSelect, onDeselect, onMemoChange }: {
  prize: PrizeObject;
  onSelect: (prizeNum: number) => void;
  onDeselect: (prizeNum: number) => void;
  onMemoChange: (prizeNum: number, memo: string) => void;
}) {
  const prizeNum = prize.prizeNum!; // このステップでは必ず存在する
  const isSelected = prize.isSelected;

  const handleClick = () => {
    if (!isSelected) {
      onSelect(prizeNum);
    }
  };
  
  const handleDoubleClick = () => {
    if (isSelected) {
      onDeselect(prizeNum);
    }
  };

  return (
    <div className="flex flex-col">
      {/* 景品番号ボタン */}
      <button
        onClick={handleClick}
        onDoubleClick={handleDoubleClick}
        className={`relative flex items-center justify-center h-20 w-full rounded-lg border-2 transition-all duration-200
          ${isSelected
            ? 'bg-gray-300 border-gray-400 text-gray-500 cursor-not-allowed shadow-inner' // 選択済み
            : 'bg-blue-100 border-blue-300 text-blue-700 hover:bg-blue-200 hover:border-blue-400 cursor-pointer shadow-sm' // 未選択
          }`}
      >
        <span className="text-3xl font-bold">{prizeNum}</span>
        {isSelected && <CheckIcon className="w-6 h-6 absolute top-1 right-1 text-gray-600" />}
      </button>
      
      {/* 選択済みの場合はメモ欄を表示 */}
      {isSelected && (
        <input
          type="text"
          value={prize.memo}
          onChange={(e) => onMemoChange(prizeNum, e.target.value)}
          placeholder="メモ (例: 学籍番号)"
          className="w-full mt-2 p-1.5 text-sm border border-gray-300 rounded focus:ring-1 focus:ring-blue-500"
        />
      )}
    </div>
  );
}


// --- ステップ4：景品発表コンポーネント ---
interface AnnouncePrizeStepProps {
  prizeObjectList: PrizeObject[];
  setPrizeObjectList: React.Dispatch<React.SetStateAction<PrizeObject[]>>;
  numberOfPeople: number;
  activePrizes: PrizeObject[];
  numberOfActivePrizes: number;
}

function AnnouncePrizeStep({
  setPrizeObjectList,
  numberOfPeople,
  activePrizes,
  numberOfActivePrizes
}: AnnouncePrizeStepProps) {

  // 発表済みの景品数
  const announcedPrizesCount = activePrizes.filter(p => p.isAnnounced).length;
  // 残りの未発表景品数
  const remainingPrizesCount = numberOfActivePrizes - announcedPrizesCount;
  // 全て発表済みか
  const allPrizesAnnounced = remainingPrizesCount === 0;

  /**
   * 景品（発表順リスト）をクリック（発表）
   * @param id 発表する景品のID
   */
  const handleAnnouncePrize = (id: string) => {
    setPrizeObjectList(prevList =>
      prevList.map(prize =>
        prize.id === id ? { ...prize, isAnnounced: true } : prize
      )
    );
  };
  
  /**
   * 景品（発表順リスト）をダブルクリック（発表取り消し）
   * @param id 取り消す景品のID
   */
  const handleUnannouncePrize = (id: string) => {
     setPrizeObjectList(prevList =>
      prevList.map(prize =>
        prize.id === id ? { ...prize, isAnnounced: false } : prize
      )
    );
  };
  
  // 中段グリッド表示用：景品番号順にソートされたリスト
  const prizesSortedByNum = useMemo(() => {
    return [...activePrizes].sort((a, b) => (a.prizeNum || 0) - (b.prizeNum || 0));
  }, [activePrizes]);
  
  // 下段リスト表示用：発表順にソートされたリスト
  const prizesSortedByOrder = useMemo(() => {
     return [...activePrizes].sort((a, b) => a.displayOrderNum - b.displayOrderNum);
  }, [activePrizes]);


  return (
    <div className="p-6 md:p-8">
      <h2 className="text-2xl font-semibold text-gray-700 mb-2">Step 4: 景品発表</h2>
      <p className="text-gray-600 mb-2">下の「景品発表リスト」をクリックすると、景品名と番号が公開されます。ダブルクリックで発表を取り消せます。</p>
      
      {/* --- 上部：情報 --- */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-4 p-4 bg-gray-100 rounded-lg">
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-md font-medium text-gray-500">参加人数</span>
          <span className="text-2xl font-bold text-gray-800">{numberOfPeople}</span>
        </div>
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-md font-medium text-gray-500">景品数</span>
          <span className="text-2xl font-bold text-blue-600">{numberOfActivePrizes}</span>
        </div>
        <div className="flex flex-col justify-center p-3 bg-white rounded-lg shadow-sm">
          <span className="text-md font-medium text-gray-500">残り (未発表)</span>
          <span className={`text-2xl font-bold ${remainingPrizesCount > 0 ? 'text-red-600' : 'text-green-600'}`}>
            {remainingPrizesCount}
          </span>
        </div>
      </div>
      
      {/* --- 中部：景品番号グリッド (結果表示) --- */}
      <h3 className="text-xl font-semibold text-gray-700 mb-2">引換番号 対応表</h3>
      <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4 mb-4">
        {prizesSortedByNum.map(prize => (
          <AnnounceNumberBox key={prize.id} prize={prize} />
        ))}
      </div>

      {/* --- 下部：景品発表リスト --- */}
      <h3 className="text-xl font-semibold text-gray-700 mb-2">景品発表リスト (発表順)</h3>
      <div className="max-h-96 overflow-y-auto border border-gray-200 rounded-lg">
        <ul className="divide-y divide-gray-200">
          {prizesSortedByOrder.map(prize => (
            <AnnouncePrizeItem
              key={prize.id}
              prize={prize}
              onAnnounce={handleAnnouncePrize}
              onUnannounce={handleUnannouncePrize}
            />
          ))}
        </ul>
      </div>
      
      {/* --- 完了メッセージ --- */}
      {allPrizesAnnounced && (
        <div className="mt-8 p-6 bg-green-100 border-l-4 border-green-500 text-green-800 rounded-lg text-center">
          <p className="text-2xl font-semibold">
            すべての景品が発表されました！
          </p>
          <p className="mt-2">お疲れ様でした！</p>
        </div>
      )}

    </div>
  );
}

/**
 * Step 4用：中段の景品番号ボックス (発表用)
 */
function AnnounceNumberBox({ prize }: { prize: PrizeObject }) {
  const isAnnounced = prize.isAnnounced;
  return (
    <div
      className={`flex flex-col justify-between h-36 w-full rounded-lg border-2 p-3 text-center transition-all duration-300
        ${isAnnounced
          ? 'bg-yellow-100 border-yellow-300 shadow-lg scale-105' // 発表済み
          : 'bg-gray-100 border-gray-300' // 未発表
        }`}
    >
      {/* 景品番号 */}
      <div className="text-2xl font-bold text-gray-800">{prize.prizeNum}</div>
      
      {/* 景品名 */}
      <div className="text-md font-semibold wrap-break-word my-1 min-h-10 flex items-center justify-center">
        {isAnnounced ? (
          <span className="text-blue-700">{prize.prizeName}</span>
        ) : (
          <span className="text-2xl font-bold text-gray-400">
            ???
          </span>
        )}
      </div>
      
      {/* メモ */}
      <div className="text-sm text-gray-600 truncate" title={prize.memo}>
        {prize.memo || '(メモなし)'}
      </div>
    </div>
  );
}

/**
 * Step 4用：下段の景品リストアイテム (発表用)
 */
function AnnouncePrizeItem({ prize, onAnnounce, onUnannounce }: {
  prize: PrizeObject;
  onAnnounce: (id: string) => void;
  onUnannounce: (id: string) => void;
}) {
  const isAnnounced = prize.isAnnounced;

  const handleClick = () => {
    if (!isAnnounced) {
      onAnnounce(prize.id);
    }
  };

  const handleDoubleClick = () => {
    if (isAnnounced) {
      onUnannounce(prize.id);
    }
  };

  return (
    <li
      onClick={handleClick}
      onDoubleClick={handleDoubleClick}
      className={`flex items-center justify-between p-4 transition-all duration-300
        ${isAnnounced
          ? 'bg-green-100 cursor-not-allowed' // 発表済み
          : 'bg-white hover:bg-gray-50 cursor-pointer' // 未発表
        }`}
    >
      {/* 発表順 と 景品名 */}
      <div className="flex items-center gap-3 overflow-hidden">
        <span className={`shrink-0 w-8 h-8 flex items-center justify-center rounded-full text-sm font-bold
          ${isAnnounced ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-700'}
        `}>
        </span>
        <span className={`text-lg font-medium truncate ${isAnnounced ? 'text-green-800' : 'text-gray-800'}`}>
          {prize.prizeName}
        </span>
      </div>
      
      {/* 景品番号 */}
      <div className="flex items-center gap-3 shrink-0 ml-4">
        {isAnnounced ? (
          <>
            <span className='text-xl font-medium text-gray-600 bg-none'>景品番号：</span>
            <span className="px-4 py-1 rounded-full bg-blue-600 text-white text-lg font-bold shadow">{prize.prizeNum}</span>
          </>
        ) : (
          <>
            <span className='text-xl font-medium text-gray-600'>景品番号：</span>
            <span className="text-2xl font-bold text-gray-400">???</span>
          </>
        )}
      </div>
    </li>
  );
}
</file>

<file path="bingo-num-app/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="bingo-num-app/imges/edit_icon.svg">
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"/></svg>
</file>

<file path="bingo-num-app/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="bingo-num-app/postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="bingo-num-app/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="bingo-num-app/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts",
    ".next\\dev/types/**/*.ts",
    ".next\\dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="bingo-num-app/app/page.tsx">
import { redirect } from "next/navigation";

export default function Home() {
  redirect("/ver-2")

  return (
    <div>
hello
    </div>
  );
}
</file>

<file path="bingo-num-app/package.json">
{
  "name": "bingo-num-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@heroicons/react": "^2.2.0",
    "next": "16.0.10",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "react-use": "^17.6.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.0.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="README.md">
# 景品番号管理アプリ

これは、イベント（ビンゴ大会など）で使用する景品の引換番号と、対応する景品名を管理するためのWebアプリケーションです。

## 概要

このアプリは、イベントの参加人数と景品数を管理し、景品と引換番号をランダムかつ公平に紐付け、発表するまでの一連のフローをサポートします。
従来の手作業による番号割り当てや、参加人数の変動に伴う管理の煩雑さを解消し、人為的なミスを防ぐことを目的としています。

## 主な特徴

* ステップバイステップのUI: 処理の流れを4つのステップに分け、直感的に操作できます。

  1. 景品入力: 景品リストを改行区切りで入力します。

  2. 人数入力 & 調整: 参加人数を入力し、景品リストの発表順をドラッグ＆ドロップで並べ替えます。また、参加人数より景品が多い場合は、景品を除外して数を調整します。

  3. 番号選択: ビンゴした人が選んだ引換番号を選択状態にし、メモ（当選者名など）を記録できます。

  4. 景品発表: 発表順リストをクリックすることで、対応する引換番号と景品名を公開します。

* 公平なシャッフル: Fisher–Yates shuffle アルゴリズムを使用し、景品と引換番号を公平にランダムで割り当てます。

* 柔軟な景品管理: 参加人数が景品数を下回る（参加人数 < 景品数）場合、エラーを防ぐため処理を開始できません。参加人数に合わせて景品を除外（isExcluded）し、有効な景品数（numberOfActivePrizes）を参加人数以下に調整する必要があります。

* シングルページアプリケーション (SPA): useStateによる状態管理で画面遷移なしにシームレスな体験を提供します。

## 技術スタック

このアプリケーションはフロントエンドのみで構成されています。

* フレームワーク: Next.js (App Router)

* 言語: TypeScript

* スタイリング: Tailwind CSS

* 主要ライブラリ:

  * @dnd-kit/core: ドラッグ＆ドロップ機能のコア

  * @dnd-kit/sortable: 並べ替え可能なリストの実装

  * @heroicons/react: UI用のアイコン

## セットアップと実行方法

1. リポジトリをクローンします:

```
git clone [リポジトリURL]
cd [リポジトリ名]
```


2. 依存関係をインストールします:

```
npm install
# または
yarn install
```


3. 開発サーバーを起動します:


```
npm run dev
# または
yarn dev
```

4. ブラウザで http://localhost:3000 にアクセスします。

## デプロイ

このアプリケーションはNext.jsプロジェクトとして、Vercelへのデプロイに最適化されています。
</file>

</files>
